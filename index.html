<!doctype html>

<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Altseason Momentum Candle Chart — Market 24h % (EMA14/70/200)</title>
  <style>
    :root{--bg:#0b0f17;--panel:#071427;--muted:#9fb0c8;--up:#2ecc71;--down:#ff6b6b}
    html,body{height:100%;margin:0;font-family:Inter,system-ui,Arial;background:var(--bg);color:#e6eef8}
    header{display:flex;align-items:center;gap:12px;padding:12px;border-bottom:1px solid rgba(255,255,255,0.03);background:linear-gradient(90deg,#04101a,#071427)}
    .brand{font-weight:700}
    .controls{display:flex;gap:8px;margin-left:auto;align-items:center}
    select,input,button{background:#061527;color:#e6eef8;border:1px solid #19303f;padding:8px;border-radius:8px}
    #app{display:flex;gap:12px;padding:12px;height:calc(100% - 64px)}
    #chartWrap{flex:1;background:var(--panel);border-radius:8px;padding:12px;display:flex;flex-direction:column}
    #chart{flex:1;border-radius:6px}
    #side{width:340px;background:linear-gradient(180deg,#071427,#061424);border-radius:8px;padding:12px}
    .row{display:flex;justify-content:space-between;margin-bottom:8px}
    .muted{color:var(--muted);font-size:13px}
    .small{font-size:12px;color:var(--muted)}
    .green{color:var(--up)}.red{color:var(--down)}
    footer{padding:8px 12px;font-size:13px;color:var(--muted)}
    .loader{font-size:13px;color:var(--muted)}
  </style>
</head>
<body>
  <header>
    <div class="brand">Altseason Momentum — 24h Market % Candles</div>
    <div class="small muted">Each candle = aggregated daily % change across selected perpetual USDT alt futures (open/high/low/close are % values)</div>
    <div class="controls">
      <label class="small muted">Days</label>
      <select id="days"><option value="30">30</option><option value="90">90</option><option value="180">180</option></select>
      <label class="small muted">Top Alts</label>
      <select id="topn"><option value="20">Top 20</option><option value="50" selected>Top 50</option><option value="100">Top 100</option></select>
      <label class="small muted">Exclude Majors</label>
      <select id="excludeMajors"><option value="true" selected>Exclude BTC & ETH</option><option value="false">Include BTC/ETH</option></select>
      <button id="loadBtn">Load</button>
    </div>
  </header>  <div id="app">
    <div id="chartWrap">
      <div id="chart"></div>
      <div style="margin-top:8px;display:flex;gap:12px;align-items:center">
        <div class="loader" id="status">Ready</div>
        <div class="small muted">Tip: Run via local HTTP server (python -m http.server) to avoid CORS issues.</div>
      </div>
    </div>
    <div id="side">
      <div class="row"><div class="muted">Range</div><div id="rangeVal">—</div></div>
      <div class="row"><div class="muted">Last Candle (Close %)</div><div id="lastClose">—</div></div>
      <div class="row"><div class="muted">EMA14</div><div id="ema14">—</div></div>
      <div class="row"><div class="muted">EMA70</div><div id="ema70">—</div></div>
      <div class="row"><div class="muted">EMA200</div><div id="ema200">—</div></div>
      <hr style="border:none;border-top:1px solid rgba(255,255,255,0.03);margin:12px 0"/>
      <div class="muted small">BTC / ETH Lines (daily %)</div>
      <div class="row"><div class="muted">BTC Latest</div><div id="btcVal">—</div></div>
      <div class="row"><div class="muted">ETH Latest</div><div id="ethVal">—</div></div>
      <hr style="border:none;border-top:1px solid rgba(255,255,255,0.03);margin:12px 0"/>
      <div class="small muted">Notes</div>
      <ul class="small muted">
        <li>Data: Binance Futures (USDT perpetual) via public REST.</li>
        <li>Candles computed from daily klines per symbol: percent = (close-open)/open * 100</li>
        <li>Open of aggregated candle = previous day's aggregated close.</li>
      </ul>
    </div>
  </div>  <footer>Built for Var — Dark TradingView-style lightweight chart with EMA overlays.</footer>  <script src="https://unpkg.com/lightweight-charts/dist/lightweight-charts.standalone.production.js"></script>  <script>
    const API = 'https://fapi.binance.com';
    const daysSelect = document.getElementById('days');
    const topnSelect = document.getElementById('topn');
    const excludeMajorsSelect = document.getElementById('excludeMajors');
    const loadBtn = document.getElementById('loadBtn');
    const status = document.getElementById('status');
    const rangeVal = document.getElementById('rangeVal');
    const lastCloseEl = document.getElementById('lastClose');
    const ema14El = document.getElementById('ema14');
    const ema70El = document.getElementById('ema70');
    const ema200El = document.getElementById('ema200');
    const btcVal = document.getElementById('btcVal');
    const ethVal = document.getElementById('ethVal');

    let chart, candleSeries, ema14Series, ema70Series, ema200Series, btcSeries, ethSeries;

    function fmt(n){ return typeof n==='number' ? n.toFixed(2)+'%' : '—'; }

    function computeEMA(values, period){
      const k = 2/(period+1);
      const out = [];
      let prev;
      for(let i=0;i<values.length;i++){
        const v = values[i];
        if(prev===undefined){ prev = v; out.push(v); }
        else{ prev = v*k + prev*(1-k); out.push(prev); }
      }
      return out;
    }

    function initChart(){
      document.getElementById('chart').innerHTML = '';
      chart = LightweightCharts.createChart(document.getElementById('chart'), {
        width: document.getElementById('chart').clientWidth,
        height: document.getElementById('chart').clientHeight,
        layout: { backgroundColor: '#071427', textColor: '#dbeefc' },
        grid: { vertLines: { color: '#0d2330' }, horzLines: { color: '#0d2330' } },
        rightPriceScale: { borderColor: '#172737' },
        timeScale: { borderColor: '#172737', timeVisible: true }
      });
      candleSeries = chart.addCandlestickSeries({ upColor:'#2ecc71', downColor:'#ff6b6b', borderVisible:true, wickUpColor:'#2ecc71', wickDownColor:'#ff6b6b' });
      ema14Series = chart.addLineSeries({ color:'#ffd14d', lineWidth:2 });
      ema70Series = chart.addLineSeries({ color:'#7bd3ff', lineWidth:2 });
      ema200Series = chart.addLineSeries({ color:'#c38cff', lineWidth:2 });
      btcSeries = chart.addLineSeries({ color:'#ff9f43', lineWidth:2 });
      ethSeries = chart.addLineSeries({ color:'#9ae6b4', lineWidth:2 });
      window.addEventListener('resize', ()=> chart.applyOptions({ width: document.getElementById('chart').clientWidth, height: document.getElementById('chart').clientHeight }));
    }

    async function fetchSymbols(){
      try{
        const res = await fetch(API+'/fapi/v1/exchangeInfo');
        const j = await res.json();
        const syms = j.symbols.filter(s=> s.contractType==='PERPETUAL' && s.status==='TRADING' && s.symbol.endsWith('USDT'))
                          .map(s=>({symbol:s.symbol, base:s.baseAsset, quote:s.quoteAsset}));
        return syms;
      }catch(e){ console.warn('exchangeInfo failed',e); return [] }
    }

    // limit concurrency helper
    async function pMap(list, fn, concurrency=6){
      const results = [];
      const executing = [];
      for(const item of list){
        const p = Promise.resolve().then(()=>fn(item));
        results.push(p);
        executing.push(p);
        if(executing.length>=concurrency) await Promise.race(executing).catch(()=>{});
        executing.splice(executing.findIndex(x=>x===p),1);
      }
      return Promise.all(results);
    }

    async function loadData(){
      status.textContent = 'Fetching symbol list...';
      const allSymbols = await fetchSymbols();
      if(!allSymbols.length) { status.textContent='Failed to load symbols'; return; }

      const includeMajors = excludeMajorsSelect.value === 'false';
      // filter out BTC and ETH from alts if requested
      let alts = allSymbols.filter(s=> !(s.symbol==='BTCUSDT' || s.symbol==='ETHUSDT'));
      if(includeMajors){ alts = allSymbols; }

      // pick top N by symbol list order (not by liquidity here). For a better approach, fetch 24hr volume and sort by volume.
      status.textContent = 'Fetching 24h volumes to rank top symbols...';
      const tickersResp = await fetch(API+'/fapi/v1/ticker/24hr');
      const tickers = await tickersResp.json();
      const tickerMap = new Map(tickers.map(t=>[t.symbol,t]));
      // attach volume
      alts.forEach(s=>{ const t=tickerMap.get(s.symbol); s.volume = t? Number(t.quoteVolume) : 0; });
      alts.sort((a,b)=> b.volume - a.volume);

      const topN = parseInt(topnSelect.value || '50',10);
      const selectedAlts = alts.slice(0, topN);

      const days = parseInt(daysSelect.value,10) || 30;

      // for each symbol fetch daily klines
      status.textContent = `Fetching daily klines for ${selectedAlts.length} symbols (this may take a few seconds)...`;
      const limit = days + 5;
      const fetchK = async (s)=>{
        try{
          const resp = await fetch(`${API}/fapi/v1/klines?symbol=${s.symbol}&interval=1d&limit=${limit}`);
          const j = await resp.json();
          // map to {time, open, high, low, close}
          const arr = j.map(k=>({time: Math.floor(k[0]/1000), open: Number(k[1]), high:Number(k[2]), low:Number(k[3]), close:Number(k[4])}));
          return {symbol:s.symbol,base:s.base,arr};
        }catch(e){ console.warn('kline failed',s.symbol,e); return {symbol:s.symbol,arr:[]}; }
      };

      const klines = (await pMap(selectedAlts, fetchK, 6)).filter(x=>x.arr && x.arr.length>=days);
      if(!klines.length){ status.textContent='No kline data'; return; }

      status.textContent = 'Aggregating daily percent changes...';
      // build per-day aggregated candles over the last `days` days using aligned kline indices (we'll align by timestamps)
      // find common timestamps intersection
      const timelines = klines.map(k=>k.arr.map(x=>x.time));
      // find the last `days` timestamps common to majority by taking the timestamps from first symbol's last days
      const ref = klines[0].arr.slice(-days).map(x=>x.time);

      const candles = [];
      for(let i=0;i<ref.length;i++){
        const t = ref[i];
        // for each symbol, find the k at same time
        const percs = [];
        for(const k of klines){
          const rec = k.arr.find(r=>r.time===t);
          if(rec){ const p = (rec.close - rec.open)/rec.open * 100; percs.push(p); }
        }
        if(percs.length===0) continue;
        const avg = percs.reduce((a,b)=>a+b,0)/percs.length;
        const high = Math.max(...percs);
        const low = Math.min(...percs);
        const open = candles.length? candles[candles.length-1].close : avg; // previous day's close
        const close = avg;
        candles.push({ time: t, open: Number(open.toFixed(6)), high: Number(high.toFixed(6)), low: Number(low.toFixed(6)), close: Number(close.toFixed(6)) });
      }

      // prepare BTC and ETH lines using same kline fetch
      status.textContent = 'Fetching BTC/ETH daily lines...';
      const majors = ['BTCUSDT','ETHUSDT'];
      const majorLines = {};
      for(const m of majors){
        try{
          const r = await fetch(`${API}/fapi/v1/klines?symbol=${m}&interval=1d&limit=${limit}`);
          const j = await r.json();
          const arr = j.map(k=>({time:Math.floor(k[0]/1000), open:Number(k[1]), close:Number(k[4])}));
          // compute percent per day aligned with ref
          const series = arr.filter(x=> ref.includes(x.time)).map(x=>({time: x.time, value: (x.close - x.open)/x.open * 100 }));
          majorLines[m] = series;
        }catch(e){ console.warn('majors failed',m,e); }
      }

      status.textContent = 'Rendering chart...';
      initChart();
      // set candle data
      candleSeries.setData(candles.map(c=>({time: c.time, open:c.open, high:c.high, low:c.low, close:c.close})));
      // EMAs on close series
      const closes = candles.map(c=>c.close);
      const ema14 = computeEMA(closes,14);
      const ema70 = computeEMA(closes,70);
      const ema200 = computeEMA(closes,200);
      const ema14Data = candles.map((c,i)=>({time:c.time, value: ema14[i]}));
      const ema70Data = candles.map((c,i)=>({time:c.time, value: ema70[i]}));
      const ema200Data = candles.map((c,i)=>({time:c.time, value: ema200[i]}));
      ema14Series.setData(ema14Data);
      ema70Series.setData(ema70Data);
      ema200Series.setData(ema200Data);

      // btc/eth lines
      if(majorLines['BTCUSDT']) btcSeries.setData(majorLines['BTCUSDT']);
      if(majorLines['ETHUSDT']) ethSeries.setData(majorLines['ETHUSDT']);

      // update sidebar
      rangeVal.textContent = `${candles.length} days`; 
      const last = candles[candles.length-1];
      lastCloseEl.textContent = fmt(last.close);
      ema14El.textContent = fmt(ema14[ema14.length-1]);
      ema70El.textContent = fmt(ema70[ema70.length-1]);
      ema200El.textContent = fmt(ema200[ema200.length-1]);
      if(majorLines['BTCUSDT'] && majorLines['BTCUSDT'].length) btcVal.textContent = fmt(majorLines['BTCUSDT'][majorLines['BTCUSDT'].length-1].value);
      if(majorLines['ETHUSDT'] && majorLines['ETHUSDT'].length) ethVal.textContent = fmt(majorLines['ETHUSDT'][majorLines['ETHUSDT'].length-1].value);

      status.textContent = 'Done';
    }

    loadBtn.addEventListener('click', ()=>{ status.textContent='Starting...'; loadData().catch(e=>{ console.error(e); status.textContent='Error'; }); });

    // initial load
    (async ()=>{ initChart(); status.textContent='Ready — click Load'; })();
  </script></body>
</html>
