<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>15m Max Zone Pump & Dump Detector (Green 3%+ Movers)</title>
  <style>
    body {
      font-family: Inter, sans-serif;
      background: #0b1120;
      color: #fff;
      padding: 20px;
    }
    h1 { color: #38bdf8; }
    .section { margin-top: 20px; }
    .pump { color: #22c55e; font-weight: bold; }
    .dump { color: #ef4444; font-weight: bold; }
    .symbol { font-weight: 600; }
    .meta { color: #94a3b8; font-size: 0.9em; }
    .highlight {
      background: rgba(56,189,248,0.2);
      border-left: 4px solid #38bdf8;
      padding: 4px 8px;
      border-radius: 8px;
    }
    #status { margin-top: 10px; color: #94a3b8; font-size: 0.9em; }
    #status strong { color: #38bdf8; }
  </style>
</head>
<body>
  <h1>üß† 15-Minute Max Zone Pump & Dump Detector (Green 3%+ Movers)</h1>
  <p>Scans Binance Futures USDT pairs with 24h price change ‚â• +3% only. Auto-refresh every 5 minutes.</p>

  <div id="status">‚è≥ Initializing...</div>

  <div class="section">
    <h2 class="pump">Max Zone Pump</h2>
    <ul id="pump-list"></ul>
  </div>

  <div class="section">
    <h2 class="dump">Max Zone Dump</h2>
    <ul id="dump-list"></ul>
  </div>

  <p id="last-update" style="color:#94a3b8;margin-top:20px;font-size:0.9em;"></p>

  <script>
    const API_URL = "https://fapi.binance.com";
    const TIMEFRAME = "15m";
    const BATCH_SIZE = 3;
    const INTERVAL_MS = 8000;
    const RSI_PERIOD = 14;
    const MIN_DELAY = 800;
    const MAX_DELAY = 1500;
    const MAX_ITEMS = 10;

    let symbols = [];
    let movers = [];
    let currentIndex = 0;
    const activeSignals = {};
    const delay = (ms) => new Promise(res => setTimeout(res, ms));
    const updateStatus = (msg) => (document.getElementById("status").innerHTML = msg);

    const blacklist = [
      "ALPACAUSDT","BNXUSDT","ALPHAUSDT","OCEANUSDT","DGBUSDT","AGIXUSDT",
      "LINAUSDT","LOKAUSDT","KEYUSDT","MDTUSDT","LOOMUSDT","RENUSDT",
      "OMNIUSDT","SLERFUSDT","STMXUSDT","UXLINKUSDT","BSWUSDT",
      "NEIROETHUSDT","VIDTUSDT","TROYUSDT","BAKEUSDT","AMBUSDT",
      "MEMEFIUSDT","NULSUSDT","HIFIUSDT","LEVERUSDT","XEMUSDT",
      "STRAXUSDT","COMBOUSDT"
    ];

    // ‚úÖ Fetch latest 24h tickers and filter green +3%
    async function fetchTopMovers() {
      updateStatus("üìä Updating 24h price change data...");
      const res = await fetch(`${API_URL}/fapi/v1/ticker/24hr`);
      const data = await res.json();

      movers = data
        .filter(d =>
          d.symbol.endsWith("USDT") &&
          !blacklist.includes(d.symbol) &&
          parseFloat(d.priceChangePercent) >= 3
        )
        .map(d => ({
          symbol: d.symbol,
          price: parseFloat(d.lastPrice),
          change: parseFloat(d.priceChangePercent)
        }));

      symbols = movers.map(m => m.symbol);
      updateStatus(`‚úÖ Loaded ${symbols.length} bullish movers (+3%).`);
    }

    async function getKlines(symbol) {
      const res = await fetch(`${API_URL}/fapi/v1/klines?symbol=${symbol}&interval=${TIMEFRAME}&limit=100`);
      const data = await res.json();
      return data.map(k => parseFloat(k[4]));
    }

    function calculateRSI(closes, period = RSI_PERIOD) {
      let gains = 0, losses = 0;
      for (let i = 1; i < period; i++) {
        const diff = closes[i] - closes[i - 1];
        if (diff >= 0) gains += diff; else losses -= diff;
      }
      let avgGain = gains / period;
      let avgLoss = losses / period;
      const rsiArr = [];
      for (let i = period; i < closes.length; i++) {
        const diff = closes[i] - closes[i - 1];
        const gain = diff > 0 ? diff : 0;
        const loss = diff < 0 ? -diff : 0;
        avgGain = (avgGain * (period - 1) + gain) / period;
        avgLoss = (avgLoss * (period - 1) + loss) / period;
        const rs = avgLoss === 0 ? 100 : avgGain / avgLoss;
        const rsi = 100 - 100 / (1 + rs);
        rsiArr.push(rsi);
      }
      return rsiArr;
    }

    function detectZone(rsi) {
      const recent = rsi.slice(-RSI_PERIOD);
      const high = Math.max(...recent);
      const low = Math.min(...recent);
      const diff = high - low;
      const start = recent[0];
      const end = recent[recent.length - 1];
      const direction = end > start ? "pump" : end < start ? "dump" : "neutral";
      if (direction === "pump" && diff >= 30) return "MAX ZONE PUMP";
      if (direction === "dump" && diff >= 30) return "MAX ZONE DUMP";
      return null;
    }

    async function analyzeSymbol(symbol) {
      try {
        const closes = await getKlines(symbol);
        const rsi = calculateRSI(closes);
        const zone = detectZone(rsi);
        if (!zone) return null;
        const ticker = movers.find(m => m.symbol === symbol);
        const timestamp = new Date().toLocaleTimeString();
        return {
          symbol,
          zone,
          price: ticker?.price.toFixed(4) ?? "‚Äî",
          change: ticker?.change.toFixed(2) ?? "0.00",
          time: timestamp
        };
      } catch {
        return null;
      }
    }

    async function fetchBatch() {
      if (symbols.length === 0) return;

      const batch = symbols.slice(currentIndex, currentIndex + BATCH_SIZE);
      currentIndex = (currentIndex + BATCH_SIZE) % symbols.length;
      updateStatus(`üîç Scanning batch of ${batch.length} pairs (index ${currentIndex})...`);

      const results = [];
      for (const symbol of batch) {
        const result = await analyzeSymbol(symbol);
        if (result) results.push(result);
        const delayTime = MIN_DELAY + Math.random() * (MAX_DELAY - MIN_DELAY);
        await delay(delayTime);
      }

      if (results.length === 0) {
        updateStatus(`‚è∏Ô∏è No new signals found.`);
        return;
      }

      const pumpList = document.getElementById("pump-list");
      const dumpList = document.getElementById("dump-list");

      results.forEach(result => {
        // Avoid duplicates
        if (activeSignals[result.symbol]) return;

        const list = result.zone.includes("PUMP") ? pumpList : dumpList;
        const item = document.createElement("li");
        const color = result.zone.includes("PUMP") ? "#22c55e" : "#ef4444";

        item.innerHTML = `
          <div>
            <span class="symbol">${result.symbol}</span> ‚Üí ${result.zone}
            <span class="meta">
              | üí∞ ${result.price} | 
              <span style="color:${color};">${result.change}%</span> | 
              üïí ${result.time}
            </span>
          </div>
        `;

        list.prepend(item);
        activeSignals[result.symbol] = item;

        // Remove older signals beyond MAX_ITEMS
        while (list.children.length > MAX_ITEMS) list.removeChild(list.lastChild);
      });

      document.getElementById("last-update").textContent =
        "Last updated: " + new Date().toLocaleTimeString();
      updateStatus(`‚úÖ Batch done ‚Äî next in ${INTERVAL_MS / 1000}s.`);
    }

    async function runScanner() {
      await fetchTopMovers();
      await fetchBatch();

      setInterval(fetchBatch, INTERVAL_MS);       // continuous scan
      setInterval(fetchTopMovers, 300000);        // refresh movers every 5 min
      setInterval(() => {                         // clear outdated signals every 10 min
        Object.keys(activeSignals).forEach(sym => {
          activeSignals[sym].remove();
          delete activeSignals[sym];
        });
        updateStatus("‚ôªÔ∏è Cleared outdated signals.");
      }, 600000);
    }

    runScanner();
  </script>
</body>
</html>
