<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>15m Max Zone Pump & Dump Detector (Green 3%+ Movers)</title>
  <style>
    body {
      font-family: Inter, sans-serif;
      background: #0b1120;
      color: #fff;
      padding: 20px;
    }
    h1 { color: #38bdf8; }
    .section { margin-top: 20px; }
    .pump { color: #22c55e; font-weight: bold; }
    .dump { color: #ef4444; font-weight: bold; }
    .symbol { font-weight: 600; }
    .meta { color: #94a3b8; font-size: 0.9em; }
    .highlight {
      background: rgba(56,189,248,0.2);
      border-left: 4px solid #38bdf8;
      padding: 4px 8px;
      border-radius: 8px;
    }
    #status { margin-top: 10px; color: #94a3b8; font-size: 0.9em; }
    #status strong { color: #38bdf8; }
  </style>
</head>
<body>
  <h1>üß† 15-Minute Max Zone Pump & Dump Detector (Green 3%+ Movers)</h1>
  <p>Scanning Binance Futures USDT pairs with 24h price change ‚â• +3% only (bullish movers).</p>

  <div id="status">‚è≥ Initializing...</div>

  <div class="section">
    <h2 class="pump">Max Zone Pump</h2>
    <ul id="pump-list"></ul>
  </div>

  <div class="section">
    <h2 class="dump">Max Zone Dump</h2>
    <ul id="dump-list"></ul>
  </div>

  <p id="last-update" style="color:#94a3b8;margin-top:20px;font-size:0.9em;"></p>

  <script>
    const API_URL = "https://fapi.binance.com";
    const TIMEFRAME = "15m";
    const BATCH_SIZE = 3;     // small batch = safer rate usage
    const INTERVAL_MS = 7000; // 7 seconds between batches
    const RSI_PERIOD = 14;
    const MIN_DELAY = 600;
    const MAX_DELAY = 1200;
    const MAX_ITEMS = 10;
    let movers = [];
    let symbols = [];
    let currentIndex = 0;

    // ‚õî Blacklist from your TSX
    const blacklist = [
      "ALPACAUSDT","BNXUSDT","ALPHAUSDT","OCEANUSDT","DGBUSDT","AGIXUSDT",
      "LINAUSDT","LOKAUSDT","KEYUSDT","MDTUSDT","LOOMUSDT","RENUSDT",
      "OMNIUSDT","SLERFUSDT","STMXUSDT","UXLINKUSDT","BSWUSDT",
      "NEIROETHUSDT","VIDTUSDT","TROYUSDT","BAKEUSDT","AMBUSDT",
      "MEMEFIUSDT","NULSUSDT","HIFIUSDT","LEVERUSDT","XEMUSDT",
      "STRAXUSDT","COMBOUSDT"
    ];

    const delay = (ms) => new Promise(res => setTimeout(res, ms));
    const updateStatus = (msg) => (document.getElementById("status").innerHTML = msg);
    const activeSignals = {};

    // ‚úÖ Fetch only bullish movers (24h price change ‚â• +3%)
    async function fetchTopMovers() {
      updateStatus("üìä Fetching 24h bullish movers...");
      const res = await fetch(`${API_URL}/fapi/v1/ticker/24hr`);
      const data = await res.json();

      movers = data
        .filter(d =>
          d.symbol.endsWith("USDT") &&
          !blacklist.includes(d.symbol) &&
          parseFloat(d.priceChangePercent) >= 3 // only green above 3%
        )
        .map(d => ({
          symbol: d.symbol,
          change: parseFloat(d.priceChangePercent),
          price: parseFloat(d.lastPrice)
        }));

      symbols = movers.map(m => m.symbol);
      updateStatus(`üî• Found <strong>${symbols.length}</strong> bullish pairs (+3%).`);
      console.log("Top movers:", movers);
    }

    async function getKlines(symbol) {
      const res = await fetch(`${API_URL}/fapi/v1/klines?symbol=${symbol}&interval=${TIMEFRAME}&limit=100`);
      const data = await res.json();
      return data.map(k => parseFloat(k[4])); // closes only
    }

    function calculateRSI(closes, period = RSI_PERIOD) {
      let gains = 0, losses = 0;
      for (let i = 1; i < period; i++) {
        const diff = closes[i] - closes[i - 1];
        if (diff >= 0) gains += diff;
        else losses -= diff;
      }
      let avgGain = gains / period;
      let avgLoss = losses / period;
      const rsiArr = [];
      for (let i = period; i < closes.length; i++) {
        const diff = closes[i] - closes[i - 1];
        const gain = diff > 0 ? diff : 0;
        const loss = diff < 0 ? -diff : 0;
        avgGain = (avgGain * (period - 1) + gain) / period;
        avgLoss = (avgLoss * (period - 1) + loss) / period;
        const rs = avgLoss === 0 ? 100 : avgGain / avgLoss;
        const rsi = 100 - 100 / (1 + rs);
        rsiArr.push(rsi);
      }
      return rsiArr;
    }

    // üîç Detect pump or dump RSI zone
    function detectZone(rsi) {
      const recent = rsi.slice(-RSI_PERIOD);
      const high = Math.max(...recent);
      const low = Math.min(...recent);
      const diff = high - low;
      const start = recent[0];
      const end = recent[recent.length - 1];
      const direction = end > start ? "pump" : end < start ? "dump" : "neutral";

      if (direction === "pump" && diff >= 30) return "MAX ZONE PUMP";
      if (direction === "dump" && diff >= 30) return "MAX ZONE DUMP";
      return null;
    }

    async function analyzeSymbol(symbol) {
      try {
        const closes = await getKlines(symbol);
        const rsi = calculateRSI(closes);
        const zone = detectZone(rsi);
        if (!zone) return null;
        const ticker = movers.find(m => m.symbol === symbol);
        const timestamp = new Date().toLocaleTimeString();
        return {
          symbol,
          zone,
          price: ticker?.price.toFixed(4) ?? "‚Äî",
          change: ticker?.change.toFixed(2) ?? "0.00",
          time: timestamp
        };
      } catch {
        return null;
      }
    }

    async function fetchBatch() {
      if (symbols.length === 0) return;

      const batch = symbols.slice(currentIndex, currentIndex + BATCH_SIZE);
      currentIndex = (currentIndex + BATCH_SIZE) % symbols.length;
      updateStatus(`üîç Scanning ${batch.length} pairs (start index ${currentIndex})...`);

      const results = [];
      for (const symbol of batch) {
        updateStatus(`üîé Checking <strong>${symbol}</strong>...`);
        const result = await analyzeSymbol(symbol);
        if (result) results.push(result);
        const wait = MIN_DELAY + Math.random() * (MAX_DELAY - MIN_DELAY);
        await delay(wait);
      }

      if (results.length === 0) {
        updateStatus(`‚è∏Ô∏è No signals found in this batch.`);
        return;
      }

      const maxChange = Math.max(...results.map(r => r.change));

      for (const result of results) {
        const list = result.zone.includes("PUMP")
          ? document.getElementById("pump-list")
          : document.getElementById("dump-list");

        const item = document.createElement("li");
        const color = result.zone.includes("PUMP") ? "#22c55e" : "#ef4444";
        const highlight = result.change === maxChange ? 'class="highlight"' : "";

        item.innerHTML = `
          <div ${highlight}>
            <span class="symbol">${result.symbol}</span> ‚Üí ${result.zone}
            <span class="meta">
              | üí∞ ${result.price} |
              <span style="color:${color};">${result.change}%</span> |
              üïí ${result.time}
            </span>
          </div>
        `;

        list.prepend(item);
        while (list.children.length > MAX_ITEMS) list.removeChild(list.lastChild);
      }

      document.getElementById("last-update").textContent =
        "Last updated: " + new Date().toLocaleTimeString();
      updateStatus(`‚úÖ Batch done ‚Äî next in ${INTERVAL_MS / 1000}s.`);
    }

    async function runScanner() {
      await fetchTopMovers();
      await fetchBatch();
      setInterval(fetchBatch, INTERVAL_MS);
      // Refresh mover list every 5 minutes
      setInterval(fetchTopMovers, 300000);
    }

    runScanner();
  </script>
</body>
</html>
