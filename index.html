<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Flowing Water Scanner — Binance Futures (USDT Perp)</title>
  <style>
    :root{
      --bg:#0b1020; --panel:#0f1724; --muted:#9aa4c0; --accent:#6ee7b7;
      --danger:#ff7b7b; --glass: rgba(255,255,255,0.03);
    }
    html,body{height:100%;margin:0;font-family:Inter,ui-sans-serif,system-ui,Segoe UI,Roboto,"Helvetica Neue",Arial;}
    body{background:linear-gradient(180deg,#071025 0%,#001025 100%);color:#e6eef8;padding:18px;}
    .container{max-width:1100px;margin:0 auto;}
    header{display:flex;gap:16px;align-items:center;margin-bottom:14px;}
    h1{font-size:20px;margin:0;color:var(--accent)}
    p.lead{margin:0;color:var(--muted);font-size:13px;}
    .controls{display:flex;gap:8px;flex-wrap:wrap;margin:16px 0;padding:12px;background:var(--panel);border-radius:10px;}
    label{font-size:13px;color:var(--muted);display:flex;gap:8px;align-items:center;}
    input[type="number"], select{background:var(--glass);border:1px solid rgba(255,255,255,0.04);padding:6px 8px;border-radius:6px;color:inherit}
    button{background:linear-gradient(90deg,#2dd4bf,#06b6d4);border:none;padding:8px 12px;border-radius:8px;color:#022;font-weight:700;cursor:pointer}
    button.secondary{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted)}
    table{width:100%;border-collapse:collapse;margin-top:12px;font-size:13px}
    thead th{background:rgba(255,255,255,0.02);text-align:left;padding:10px;border-bottom:1px solid rgba(255,255,255,0.03);color:var(--muted)}
    tbody td{padding:10px;border-bottom:1px dashed rgba(255,255,255,0.02)}
    .chip{display:inline-block;padding:4px 8px;border-radius:999px;background:rgba(255,255,255,0.03);font-weight:600}
    .green{color:#9ae6b4}
    .red{color:#ffb4b4}
    .small{font-size:12px;color:var(--muted)}
    footer{margin-top:18px;color:var(--muted);font-size:12px}
    .spinner{display:inline-block;width:16px;height:16px;border:2px solid rgba(255,255,255,0.08);border-top-color:var(--accent);border-radius:50%;animation:spin 1s linear infinite}
    @keyframes spin{to{transform:rotate(360deg)}}
  </style>
</head>
<body>
  <div class="container">
    <header>
      <div>
        <h1>Flowing Water Scanner (Binance Futures USDT Perp)</h1>
        <p class="lead">Scans USDT perpetual pairs for the "flowing water" short setup (24h pump, yesterday red/today green, 4h RSI overbought).</p>
      </div>
      <div style="margin-left:auto;text-align:right">
        <div class="small">Made for Var — flow-based short filter</div>
      </div>
    </header>

    <div class="controls">
      <label>
        24h change min %
        <input id="min24" type="number" value="10" step="0.1" style="width:80px"/>
      </label>
      <label>
        24h change max %
        <input id="max24" type="number" value="25" step="0.1" style="width:80px"/>
      </label>
      <label>
        4h RSI cutoff
        <input id="rsiCut" type="number" value="70" step="1" style="width:80px"/>
      </label>
      <label>
        Max BTC 24h pump %
        <input id="btcMax" type="number" value="2" step="0.1" style="width:80px"/>
      </label>
      <label>
        Max symbols to check (to avoid rate limit)
        <input id="maxSymbols" type="number" value="30" step="1" style="width:80px"/>
      </label>

      <button id="scanBtn">Scan Now</button>
      <button id="clearBtn" class="secondary">Clear Results</button>
      <div style="margin-left:auto;display:flex;gap:8px;align-items:center">
        <div id="status" class="small">Idle</div>
        <div id="spinner" style="display:none;margin-left:8px"><span class="spinner"></span></div>
      </div>
    </div>

    <div id="summary" class="small" style="margin-bottom:8px">Notes: This tool runs in your browser and uses Binance Futures public endpoints. Use responsibly.</div>

    <table id="results">
      <thead>
        <tr>
          <th>Symbol</th>
          <th>24h %</th>
          <th>4h RSI</th>
          <th>Daily trend (prev-prev → prev → latest)</th>
          <th>Last 4h candles checked</th>
          <th>Link</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>

    <footer>
      <div>How it works: fetch 24h tickers → take USDT perp symbols with 24h change in range → for top N symbols pull daily & 4h klines → compute RSI(14) and check that yesterday was red, today is green and 4h RSI &gt; cutoff. Avoids scanning if BTC pumped above the BTC pump threshold.</div>
      <div style="margin-top:8px">Caveats: Binance rate limits and CORS may block many requests; this script throttles checks to 200ms between fetches. Adjust max symbols if you hit errors.</div>
    </footer>
  </div>

<script>
(async function(){
  const API_ROOT = 'https://fapi.binance.com';
  const scanBtn = document.getElementById('scanBtn');
  const clearBtn = document.getElementById('clearBtn');
  const statusEl = document.getElementById('status');
  const spinner = document.getElementById('spinner');
  const tbody = document.querySelector('#results tbody');

  function setStatus(txt, busy=false){
    statusEl.textContent = txt;
    spinner.style.display = busy ? 'inline-block' : 'none';
  }

  function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }

  // RSI calculation (classic Wilder 14)
  function computeRSI(closes, period=14){
    if(closes.length < period+1) return null;
    let gains=0, losses=0;
    // first pass to compute initial avg gain/loss
    for(let i=1;i<=period;i++){
      const diff = closes[i] - closes[i-1];
      if(diff>0) gains += diff; else losses += Math.abs(diff);
    }
    let avgGain = gains/period;
    let avgLoss = losses/period;
    // smooth
    for(let i=period+1;i<closes.length;i++){
      const diff = closes[i] - closes[i-1];
      avgGain = (avgGain*(period-1) + (diff>0?diff:0)) / period;
      avgLoss = (avgLoss*(period-1) + (diff<0?Math.abs(diff):0)) / period;
    }
    if(avgLoss === 0) return 100;
    const rs = avgGain / avgLoss;
    const rsi = 100 - (100 / (1 + rs));
    return rsi;
  }

  // Fetch helper with basic error handling
  async function apiGET(path, query){
    const url = new URL(API_ROOT + path);
    if(query) Object.entries(query).forEach(([k,v])=>url.searchParams.append(k,v));
    const res = await fetch(url.toString());
    if(!res.ok){
      const text = await res.text().catch(()=>null);
      throw new Error('HTTP ' + res.status + ' ' + text);
    }
    return res.json();
  }

  async function scan(){
    tbody.innerHTML = '';
    setStatus('Fetching tickers...', true);

    const min24 = parseFloat(document.getElementById('min24').value);
    const max24 = parseFloat(document.getElementById('max24').value);
    const rsiCut = parseFloat(document.getElementById('rsiCut').value);
    const btcMax = parseFloat(document.getElementById('btcMax').value);
    const maxSymbols = parseInt(document.getElementById('maxSymbols').value) || 30;

    // 1) get all futures 24hr tickers
    let tickers;
    try {
      tickers = await apiGET('/fapi/v1/ticker/24hr');
    } catch(err) {
      setStatus('Failed fetching tickers: ' + err.message);
      return;
    }

    // check BTCUSDT pump
    const btc = tickers.find(t=>t.symbol==='BTCUSDT');
    if(btc){
      const btcChange = parseFloat(btc.priceChangePercent);
      if(btcChange > btcMax){
        setStatus('Aborting: BTC has pumped ' + btcChange.toFixed(2) + '% (> ' + btcMax + '%).');
        return;
      }
    }

    // filter USDT perpetuals (symbol endsWith USDT) and avoid tokenized leverage tokens or BRL etc
    let usdt = tickers.filter(t=>t.symbol.endsWith('USDT') && !t.symbol.includes('UP') && !t.symbol.includes('DOWN') && !t.symbol.includes('BEAR') && !t.symbol.includes('BULL'));
    // filter by 24h change range
    let candidates = usdt.filter(t=>{
      const ch = parseFloat(t.priceChangePercent);
      return ch >= min24 && ch <= max24;
    });

    if(candidates.length === 0){
      setStatus('No candidates found in the 24h% range.');
      return;
    }

    // sort by highest 24h change first, then limit to maxSymbols
    candidates.sort((a,b)=>parseFloat(b.priceChangePercent)-parseFloat(a.priceChangePercent));
    candidates = candidates.slice(0, maxSymbols);

    setStatus('Checking ' + candidates.length + ' candidate symbols...', true);

    // throttle fetches to avoid rate limit; for each candidate fetch daily klines and 4h klines
    const matches = [];
    for(let i=0;i<candidates.length;i++){
      const t = candidates[i];
      const sym = t.symbol;
      statusEl.textContent = `Checking ${i+1}/${candidates.length}: ${sym}`;
      try {
        // fetch daily klines (we need at least 3 days to assert prev-prev)
        const daily = await apiGET('/fapi/v1/klines', {symbol: sym, interval: '1d', limit: 5});
        // fetch 4h klines for RSI
        const kl4h = await apiGET('/fapi/v1/klines', {symbol: sym, interval: '4h', limit: 100});
        // parse closes
        const dailyCloses = daily.map(d => parseFloat(d[4])); // close is index 4
        // need at least 3 daily closes
        if(dailyCloses.length < 3){
          // skip
          await sleep(200);
          continue;
        }
        // Check yesterday red and today green:
        // dailyCloses: [oldest...latest]; last = latest close (could be partial day)
        // We'll interpret: prevPrev = at index len-3, prev = len-2, latest = len-1
        const len = dailyCloses.length;
        const prevPrevClose = dailyCloses[len-3];
        const prevClose = dailyCloses[len-2];
        const latestClose = dailyCloses[len-1];

        const yesterdayRed = prevClose < prevPrevClose;
        const todayGreen = latestClose > prevClose;

        // compute RSI(14) from closes of kl4h (close at idx 4)
        const closes4h = kl4h.map(k => parseFloat(k[4]));
        const rsi = computeRSI(closes4h, 14);

        // minimal check: RSI exists and > cutoff, and daily pattern matches
        if(rsi !== null && rsi > rsiCut && yesterdayRed && todayGreen){
          matches.push({
            symbol: sym,
            change24: parseFloat(t.priceChangePercent),
            rsi: rsi,
            prevPrevClose,
            prevClose,
            latestClose,
            recent4hCloses: closes4h.slice(-6) // last 6 closes for display
          });
        }
      } catch(err){
        // record error in console but continue
        console.warn('Error checking', sym, err);
      }
      // throttle small pause
      await sleep(220);
    }

    // populate table
    tbody.innerHTML = '';
    if(matches.length === 0){
      setStatus('No matched symbols found after checks.');
    } else {
      setStatus('Found ' + matches.length + ' matching symbol(s).', false);
      matches.forEach(m=>{
        const tr = document.createElement('tr');
        const a = `<a href="https://www.binance.com/en/futures/${m.symbol}" target="_blank" rel="noreferrer">${m.symbol}</a>`;
        tr.innerHTML = `
          <td>${a}</td>
          <td class="${m.change24>=0?'green':''}">${m.change24.toFixed(2)}%</td>
          <td>${m.rsi.toFixed(1)}</td>
          <td>
            <div class="small">prev-prev: ${m.prevPrevClose}</div>
            <div class="small">prev: ${m.prevClose}</div>
            <div class="small">latest: ${m.latestClose}</div>
          </td>
          <td class="small">${m.recent4hCloses.map(c=>c.toFixed(4)).join(', ')}</td>
          <td><a class="chip" href="https://www.binance.com/en/futures/${m.symbol}" target="_blank" rel="noreferrer">Open</a></td>
        `;
        tbody.appendChild(tr);
      });
    }
  }

  scanBtn.addEventListener('click', async ()=>{
    setStatus('Starting scan...', true);
    try {
      await scan();
    } catch(e){
      setStatus('Scan error: ' + e.message);
      console.error(e);
    }
  });

  clearBtn.addEventListener('click', ()=>{
    tbody.innerHTML = '';
    setStatus('Idle');
  });

  // optional: auto-scan on load (disabled)
  // setTimeout(()=>scanBtn.click(), 500);
})();
</script>
</body>
</html>
