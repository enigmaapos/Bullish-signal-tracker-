<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Binance Futures EMA Cross Detector</title>
  <style>
  :root {
    --bg: #0e1117;
    --card: #161b22;
    --border: #2b313b;
    --accent: #f1c40f;
    --bull: #00ff88;
    --bear: #ff5555;
    --bull-bg: rgba(0, 255, 136, 0.15);  /* üü¢ for high-vol bearish */
    --bear-bg: rgba(255, 85, 85, 0.15);  /* üî¥ for high-vol bullish */
  }

  body {
    margin: 0;
    font-family: "Segoe UI", Arial, sans-serif;
    background: var(--bg);
    color: #e0e0e0;
  }

  h1 {
    color: var(--accent);
    margin: 20px 0 5px;
    text-align: center;
  }

  p {
    text-align: center;
    color: #aaa;
    margin: 0 0 20px;
  }

  .controls {
    text-align: center;
    margin-bottom: 10px;
  }

  button {
    background: var(--accent);
    color: #000;
    font-weight: bold;
    padding: 10px 18px;
    margin: 5px;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    transition: all 0.2s;
  }

  button:hover:not(:disabled) {
    transform: scale(1.03);
    box-shadow: 0 0 8px var(--accent);
  }

  button:disabled {
    opacity: 0.4;
    cursor: not-allowed;
  }

  .dashboard {
    max-width: 1200px;
    margin: auto;
    background: var(--card);
    border: 1px solid var(--border);
    border-radius: 12px;
    padding: 20px;
    box-shadow: 0 0 15px rgba(0,0,0,0.4);
  }

  .stats {
    display: flex;
    flex-wrap: wrap;
    justify-content: space-around;
    margin: 15px 0;
  }

  .stat-box {
    background: #1b222d;
    border-radius: 10px;
    padding: 10px 20px;
    margin: 5px;
    text-align: center;
    min-width: 130px;
  }

  .stat-box span {
    display: block;
    font-size: 24px;
    font-weight: bold;
  }

  #progress-container {
    width: 100%;
    height: 10px;
    background: #2b2b2b;
    border-radius: 6px;
    overflow: hidden;
    margin: 15px 0;
  }

  #progress-bar {
    width: 0%;
    height: 100%;
    background: var(--accent);
    transition: width 0.3s;
  }

  table {
    width: 100%;
    border-collapse: collapse;
    margin-top: 15px;
  }

  th, td {
    padding: 8px;
    border-bottom: 1px solid #2b2b2b;
    text-align: center;
    font-size: 13px;
  }

  th {
    color: var(--accent);
    background: #1e2530;
  }

  tr:nth-child(even) { background: #141a22; }
  tr:nth-child(odd) { background: #10151c; }

  .ok { color: var(--bull); font-weight: bold; }
  .bear { color: var(--bear); font-weight: bold; }

  /* ‚ú® High-Volume Highlight Rows */
  .highvol-bullish {
    background: var(--bear-bg) !important;
    animation: glowRed 1.5s ease-out;
  }
  .highvol-bearish {
    background: var(--bull-bg) !important;
    animation: glowGreen 1.5s ease-out;
  }

  /* ‚ú® Glow Animation */
  @keyframes glowRed {
    from { box-shadow: 0 0 12px rgba(255,85,85,0.8); }
    to { box-shadow: 0 0 0 rgba(0,0,0,0); }
  }
  @keyframes glowGreen {
    from { box-shadow: 0 0 12px rgba(0,255,136,0.8); }
    to { box-shadow: 0 0 0 rgba(0,0,0,0); }
  }

  @media (max-width: 700px) {
    table { font-size: 12px; }
    th, td { padding: 6px; }
  }
  </style>
</head>
<body>
  <h1>Binance Futures EMA Cross Detector</h1>
  <p>Timeframe: 15m ‚Ä¢ Safe: 5 pairs/sec ‚Ä¢ Candles: 200 ‚Ä¢ Cooldown: 30s</p>

  <div class="controls">
    <button id="greenBullish">üü¢ Green Bullish</button>
    <button id="redBullish">üî¥ Red Bullish</button>
    <button id="greenBearish">üü¢ Green Bearish</button>
    <button id="redBearish">üî¥ Red Bearish</button>
  </div>

  <div class="dashboard">
    <div class="stats">
      <div class="stat-box" style="color:var(--bull)">
        Green Pairs <span id="greenCount">-</span>
      </div>
      <div class="stat-box" style="color:var(--bear)">
        Red Pairs <span id="redCount">-</span>
      </div>
      <div class="stat-box" style="color:var(--accent)">
        Found Crosses <span id="foundCount">0</span>
      </div>
    </div>

    <div id="progress-container"><div id="progress-bar"></div></div>
    <div id="progressText" style="text-align:center; margin-bottom:10px;"></div>

    <table>
  <thead>
    <tr>
      <th>Pair</th>
      <th>24h Change %</th>
      <th>Funding</th>
      <th>EMA70</th>
      <th>EMA200</th>
      <th>RSI Now</th>
      <th>Cross Type</th>
      <th>Cross Time</th>
      <th>Bars Ago</th>
    </tr>
  </thead>
  <tbody id="results"></tbody>
</table>
  </div>


      <script>
const apiBase = "https://fapi.binance.com";
const tf = "15m";
const candlesLimit = 500;
const concurrency = 10;
const delayMs = 1000;
const cooldownMs = 30000;
const autoRefreshInterval = 5 * 60 * 1000;

let isScanning = false;
let lastScanTime = 0;
let autoRefreshTimer = null;

async function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }

function ema(values, period){
  const k = 2 / (period + 1);
  const emaArr = [values[0]];
  for(let i=1;i<values.length;i++){
    emaArr.push(values[i]*k + emaArr[i-1]*(1-k));
  }
  return emaArr;
}

async function fetchCandles(symbol){
  const res = await fetch(`${apiBase}/fapi/v1/klines?symbol=${symbol}&interval=${tf}&limit=${candlesLimit}`);
  const data = await res.json();
  return data.map(c=>({
    time: c[0],
    open: parseFloat(c[1]),
    high: parseFloat(c[2]),
    low: parseFloat(c[3]),
    close: parseFloat(c[4]),
    volume: parseFloat(c[5])
  }));
}

async function get24hSymbols(){
  const res = await fetch(`${apiBase}/fapi/v1/ticker/24hr`);
  const data = await res.json();
  return data.map(t=>({
    symbol: t.symbol,
    change: parseFloat(t.priceChangePercent)
  }));
}

async function preloadCounts(){
  const tickers = await get24hSymbols();
  const greens = tickers.filter(t=>t.change>0 && t.symbol.endsWith("USDT")).length;
  const reds = tickers.filter(t=>t.change<0 && t.symbol.endsWith("USDT")).length;
  document.getElementById("greenCount").textContent = greens;
  document.getElementById("redCount").textContent = reds;
}

function calcRSI(closes, period = 14){
  let gains = 0, losses = 0;
  for(let i=1;i<=period;i++){
    const diff = closes[i]-closes[i-1];
    if(diff>=0) gains+=diff; else losses-=diff;
  }
  let avgGain = gains/period;
  let avgLoss = losses/period;
  const rsiArr = [];
  for(let i=period;i<closes.length;i++){
    const diff = closes[i]-closes[i-1];
    const gain = Math.max(0,diff);
    const loss = Math.max(0,-diff);
    avgGain = (avgGain*(period-1)+gain)/period;
    avgLoss = (avgLoss*(period-1)+loss)/period;
    const rs = avgLoss===0 ? 100 : 100 - 100/(1+avgGain/avgLoss);
    rsiArr.push(rs);
  }
  while(rsiArr.length < closes.length) rsiArr.unshift(rsiArr[0] || 50);
  return rsiArr;
}

// ‚úÖ Fetch recent funding rate (Binance Futures)
async function fetchFundingRate(symbol) {
  try {
    const res = await fetch(`${apiBase}/fapi/v1/fundingRate?symbol=${symbol}&limit=1`);
    const data = await res.json();
    return parseFloat(data?.[0]?.fundingRate ?? 0);
  } catch (err) {
    console.warn(`Funding fetch failed for ${symbol}:`, err.message);
    return 0;
  }
}

async function processSymbol({ symbol, change }, mode){
  try {
    if (mode.includes("bullish") && change < 0) return null;
    if (mode.includes("bearish") && change > 0) return null;

    // üü¢ Skip pairs with negative or zero funding
    const funding = await fetchFundingRate(symbol);
    if (funding <= 0) return null;

    // ‚ö° Skip if 24h price change is less than ¬±10%
    if (Math.abs(change) < 10) return null;

    const candles = await fetchCandles(symbol);
    if(!candles || candles.length < 300) return null;

    // === Restrict to daily window (previous ‚Üí current day) ===
    const now = new Date();
    const utcDay = Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate());
    const prevDayStart = utcDay - 24*60*60*1000;
    const currDayEnd = utcDay + 24*60*60*1000;

    const dailyWindow = candles.filter(c=>{
      const t = new Date(c.time).getTime();
      return t >= prevDayStart && t <= currDayEnd;
    });
    
    if(dailyWindow.length < 96) return null;

    const closes = dailyWindow.map(c=>c.close);
    const ema70 = ema(closes, 70);
    const ema200 = ema(closes, 200);
    const last = ema70.length - 1;
    const isBullish = mode.includes("bullish");

    // üîç Require at least one candle close inside EMA70‚ÄìEMA200 range
    const hasCandleInside = dailyWindow.some((c, idx) => {
      if (idx >= ema70.length) return false;
      const close = c.close;
      return (
        close >= Math.min(ema70[idx], ema200[idx]) &&
        close <= Math.max(ema70[idx], ema200[idx])
      );
    });
    if (!hasCandleInside) return null;

    // === Real cross detection ===
    let crossIdx = -1;
    for(let i=ema70.length-2;i>=0;i--){
      const prev70=ema70[i], curr70=ema70[i+1];
      const prev200=ema200[i], curr200=ema200[i+1];
      const crossedUp = prev70<prev200 && curr70>curr200;
      const crossedDown = prev70>prev200 && curr70<curr200;
      if(isBullish && crossedUp){ crossIdx=i+1; break; }
      else if(!isBullish && crossedDown){ crossIdx=i+1; break; }
    }

    if(crossIdx===-1) return null;

    // üß© Detect red high-volume candle near cross (ignore green candles)
const volValues = dailyWindow.map(c => c.volume);
const avgVol = volValues.reduce((a, b) => a + b, 0) / volValues.length;
const volThreshold = avgVol * 2.5; // 2.5√ó average = strong flush volume

let redHighVolDetected = false;
for (let i = Math.max(0, crossIdx - 3); i <= Math.min(dailyWindow.length - 1, crossIdx + 3); i++) {
  const c = dailyWindow[i];
  const isRed = c.close < c.open;
  if (isRed && c.volume >= volThreshold) {
    redHighVolDetected = true;
    break;
  }
}

// ‚ùå Skip if no big red high-volume candle detected near cross
if (!redHighVolDetected) return null;

    const rsi = calcRSI(closes,14);
    const rsiNow = rsi[rsi.length-1].toFixed(1);
    const barsAgo = ema70.length - 1 - crossIdx;
    const crossTime = new Date(dailyWindow[crossIdx].time)
      .toLocaleTimeString("en-US",{hour12:false});

    let crossType = isBullish ? "üü© EMA70‚Üí200 Cross" : "üü• EMA200‚Üí70 Cross";
    if (highVolDetected === "red") crossType += " üî¥ High Vol";
    if (highVolDetected === "green") crossType += " üü¢ High Vol";

    return {
      symbol,
      change,
      funding,
      ema70: ema70[last].toFixed(2),
      ema200: ema200[last].toFixed(2),
      rsiNow,
      crossTime,
      barsAgo,
      crossType,
      highVolDetected
    };

  } catch (err){
    console.error(`Error processing ${symbol}:`, err.message);
    return null;
  }
}

function disableButtons(state){
  document.querySelectorAll("button").forEach(btn=>btn.disabled=state);
}

function updateProgress(percent){
  document.getElementById("progress-bar").style.width = `${Math.min(100,percent)}%`;
}

function startAutoRefresh(mode){
  if(autoRefreshTimer) clearInterval(autoRefreshTimer);
  autoRefreshTimer = setInterval(()=>{
    console.log(`üîÅ Auto-refreshing ${mode} scan...`);
    startScan(mode, true);
  }, autoRefreshInterval);
}

function sortTableByChange(ascending = false) {
  const tbody = document.getElementById("results");
  const rows = Array.from(tbody.querySelectorAll("tr"));
  rows.sort((a, b) => {
    const valA = parseFloat(a.children[1].textContent.replace('%', ''));
    const valB = parseFloat(b.children[1].textContent.replace('%', ''));
    return ascending ? valA - valB : valB - valA;
  });
  tbody.innerHTML = "";
  rows.forEach(r => tbody.appendChild(r));
}

async function startScan(mode, auto=false){
  if(isScanning){
    if(!auto) alert("‚ö†Ô∏è Scan already running. Wait...");
    return;
  }

  const now = Date.now();
  if(!auto && (now - lastScanTime < cooldownMs)){
    return alert(`‚è≥ Wait ${(cooldownMs - (now - lastScanTime))/1000|0}s before rescanning.`);
  }

  isScanning = true;
  lastScanTime = now;
  disableButtons(true);
  updateProgress(0);

  const resultsEl = document.getElementById("results");
  const txt = document.getElementById("progressText");
  resultsEl.innerHTML = "";
  document.getElementById("foundCount").textContent = 0;

  txt.textContent = auto ? "Auto-refreshing..." : "Fetching 24h tickers...";
  const tickers = await get24hSymbols();
  const filtered = tickers.filter(t=>{
    if(!t.symbol.endsWith("USDT")) return false;
    if(mode.includes("green")) return t.change>0;
    if(mode.includes("red")) return t.change<0;
    return false;
  });

  txt.textContent = `Scanning ${filtered.length} pairs...`;

  let found = 0;
  for(let i=0;i<filtered.length;i+=concurrency){
    const batch = filtered.slice(i,i+concurrency);
    const res = await Promise.all(batch.map(s=>processSymbol(s,mode)));
    res.forEach(r=>{
      if(!r) return;
      found++;
      document.getElementById("foundCount").textContent = found;

      // üé® Highlight row background for high-volume crosses
      let bgStyle = "";
      if (r.highVolDetected === "red") bgStyle = "background-color: rgba(255, 0, 0, 0.2);";
      if (r.highVolDetected === "green") bgStyle = "background-color: rgba(0, 255, 0, 0.2);";

      const row = `<tr style="${bgStyle}">
        <td>${r.symbol}</td>
        <td style="color:${r.change>0?"#00ff88":"#ff5555"}">${r.change.toFixed(2)}%</td>
        <td>${r.funding.toFixed(4)}%</td>
        <td>${r.ema70}</td>
        <td>${r.ema200}</td>
        <td>${r.rsiNow}</td>
        <td>${r.crossType}</td>
        <td>${r.crossTime}</td>
        <td>${r.barsAgo}</td>
      </tr>`;
      resultsEl.insertAdjacentHTML("beforeend", row);
    });
    updateProgress((i+concurrency)/filtered.length*100);
    await sleep(delayMs);
  }

  sortTableByChange(false);
  txt.textContent = `‚úÖ ${auto ? "Auto-update complete" : "Scan complete"}. Found ${found} EMA crosses.`;
  disableButtons(false);
  isScanning = false;
  if(!auto) startAutoRefresh(mode);
}

document.getElementById("greenBullish").onclick=()=>startScan("green_bullish");
document.getElementById("redBullish").onclick=()=>startScan("red_bullish");
document.getElementById("greenBearish").onclick=()=>startScan("green_bearish");
document.getElementById("redBearish").onclick=()=>startScan("red_bearish");

preloadCounts();
setInterval(preloadCounts, 60000);
      </script>
</body>
</html>
